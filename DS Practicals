// N1
#include<bits/stdc++.h>
#include<conio.h>
using namespace std;

void menu(){
	cout << "Menu" << endl;
	cout << "[1] Linear Search" << endl;
	cout << "[2] Binary Search" << endl;
	cout << "[3] Fibonacci Search" << endl;
	cout << "[0] Exit" << endl;
	cout << "Enter Your Choice" << endl; 
}

void linearSearch(int size,int arr[],int target){
	
	int match_loc = -1,counter = 0;
	// Main Logic of Program
	for (int i = 0; i < size; i++)
	{
		counter++;
		if(arr[i] == target){
			match_loc = i;	
			break;
		}

	}
	if (match_loc == -1)
	{
		cout << "The element is not available in an array" << endl;
		cout << "The number of comparison performed are " << counter << endl;
	}else{
		cout << "The element is available at " << match_loc << " position" << endl;
		cout << "The number of comparison required are " << counter << endl;
	}

}

int binSearch(int arr[],int left ,int right ,int target,int* counter){
	
	(*counter)++;
	if (left <= right)
	{

		int mid = (left+right) / 2;

		if (arr[mid] == target)
		{
			return mid;
		}else if (arr[mid] > target)
		{
			return  binSearch(arr,left,mid-1,target,counter);
		}else{
			return  binSearch(arr,mid+1,right,target,counter);
		}
	}

	return -1;
}

void binarySearch(int arr[],int size, int target){
	int counter = 0;
	int *c = &counter;
	int match_loc = binSearch(arr,0,size-1,target,c);
	// cout << loc << " " << counter << endl;
	
	if (match_loc == -1)
	{
		cout << "The element is not available in an array" << endl;
		cout << "The number of comparison performed are " << counter << endl;
	}else{
		cout << "The element is available at " << match_loc << " position" << endl;
		cout << "The number of comparison required are " << counter << endl;
	}

}

int min(int a,int b){
	return a>b?b:a;
}

int fibonacciSearch(int arr[],int n,int target,int* c){

	int fib2 = 0;
	int fib1 = 1;
	int fibM = fib1 + fib2;

	while(fibM < n){
		fib2 = fib1;
		fib1 = fibM;
		fibM = fib2 + fib1;
	}

	int offset = -1;

	while (fibM > 1) {
		(*c)++; 			// Counter
		int i = min(offset + fib2, n - 1);

		if (arr[i] < target) {
			fibM = fib1;
			fib1 = fib2;
			fib2 = fibM - fib1;
			offset = i;
		}else if (arr[i] > target) {
			fibM = fib2;
			fib1 = fib1 - fib2;
			fib2 = fibM - fib1;
		}else
		return i;
	}
	// Last element
	if (fib1 && arr[offset + 1] == target){
		(*c)++;
		return offset + 1;
	}

	return -1;
}

int main()
{
	bool run = true;
	while(run){
		menu();
		int choice;
		cin >> choice;

		switch(choice){

			case 1:
			{	/* Linear Search */
				
				int n;
				cout << endl <<"Enter the size of an array ";
				cin >> n;
				int arr[n];
				cout << endl << "Enter the array elements ";
				for (int i = 0; i < n; i++)
				{
					cin >> arr[i];
				}
				int target;
				cout << "Enter the element to Search ";
				cin >> target;
				linearSearch(n,arr,target);
			}  
			break;
			case 2:
			{	/* Bianry Search */

				int n;
				cout << "Note: Please enter the elements in increasing order." << endl;
				cout << endl <<"Enter the size of an array ";
				cin >> n;
				int arr[n];
				cout << endl << "Enter the array elements ";
				for (int i = 0; i < n; i++)
				{
					cin >> arr[i];
				}
				int target;
				cout << "Enter the element to Search ";
				cin >> target;
				sort(arr,arr+n);
				binarySearch(arr,n,target);
				

			} 
			break;
			case 3:
			{	/* Fibonacci Search */

				int n;
				cout << "Note: Please enter the elements in increasing order." << endl;
				cout << endl <<"Enter the size of an array ";
				cin >> n;
				int arr[n];
				cout << endl << "Enter the array elements ";
				for (int i = 0; i < n; i++)
				{
					cin >> arr[i];
				}
				int target;
				cout << "Enter the element to Search ";
				cin >> target;
				int counter = 0;
				int* c = &counter;
				sort(arr,arr+n);
				int match_loc = fibonacciSearch(arr,n,target,c);
				if(match_loc == -1){
					cout << "The element is not available in an array" << endl;
					cout << "The number of comparison performed are " << counter << endl;
				}else{
					cout << "The element is available at " << match_loc << " position" << endl;
					cout << "The number of comparison required are " << counter << endl;
				}
			} 
			break;
			case 0:
			cout << "Closing Application.Good Bye!!!";
			run = false;
			break;
			default:
			cout << "Invalid Option" << endl;
			break;
		}
	cout << "Press Enter to continue..." << endl;
    getch();
    system("CLS");	
	}

	return 0;
}












N2
#include<bits/stdc++.h>
#include<stdio.h>
#include<conio.h>
using namespace std;

class Employee{
public:
	int empid;
	string ename;
	Employee* next;

	Employee(int empid,string ename){
		this->empid = empid;
		this->ename = ename;
		this->next = NULL;
	}

};

Employee* insertEmployee(Employee* head){

	Employee* temp = head;
	int id;
	string name;

	cout << "Enter the Employee ID : ";
	cin >> id;

	cout << "Enter the Employee Name : ";
	cin >> name;

	Employee* newEmployee = new Employee(id,name);

	if (head == NULL)
	{
		head = newEmployee;
		return head;
	}else{

		while(temp){
			if (temp->empid > id)
    			{

    				head = newEmployee;
    				newEmployee->next = temp;
    				return head;
    				
    			}

			if (temp->next == NULL)
			{
				// ID Compare
    			if (temp->empid > id)
    			{

    				head = newEmployee;
    				newEmployee->next = temp;
    				return head;
    				
    			}else{

    				temp->next = newEmployee;
    				return head;
    			}
			}else{
				Employee* temp2 = temp->next;

				if (temp2->empid < id)
				{
					temp = temp->next;
				}else{

					newEmployee->next = temp2;
					temp->next = newEmployee;
					return head;
				}
			}

		}

	}

	return head;


}

Employee* deleteEmployee(Employee* head){
	Employee* temp = head;

	if (head == NULL)
	{
		cout << "Linked List is empty." << endl;
		return NULL;
	}

	int id;
	cout << "Enter the Employee ID : ";
	cin >> id;

	if (head->next == NULL)
	{
		if (head->empid == id)
		{
			delete head;
			return NULL;
		}else{
			cout << "Employee Not Found." << endl;
			return head;
		}
	}else{

		if (head->empid == id)
		{
			Employee* temp_raw;
			temp_raw = head;
			head = head->next;
			cout << "Employee " << temp_raw->ename << " is removed." <<endl;
			delete temp_raw;
			return head;
		}
		while(temp->next){
			Employee* temp2 = temp->next;
			if (temp2->empid == id)
			{
				cout << "Employee " << temp2->ename << " is removed." <<endl;
				temp->next = temp2->next;
				delete temp2;
				return head;

			}
			temp = temp->next;
		}

		cout << "Employee Not Found." << endl;
		return head;

	}
}

void display(Employee* head){
	if (head == NULL)
	{
		cout << "Linked List is Empty" << endl;
		return;
	}
	Employee* temp = head;
	while(temp){
		cout <<"Employee ID : " << temp->empid << endl;
		cout <<"Employee Name : " << temp->ename << endl << endl;
		temp = temp->next;
	}
}

int main()
{
	system("CLS");
	Employee* head = NULL;
	bool flag = true;

	while(flag){

		int choice;
		cout << "Choose From the Following : " << endl;
		cout << "[1] Insert Employee in Linked List" << endl;
		cout << "[2] Delete Employee from Linked List" << endl;
		cout << "[3] Display Employees" << endl;
		cout << "[0] Exit" << endl;
		cout << "Enter Your Choice" << endl;
		cin >> choice;
		switch(choice){
			case 1:{

				head = insertEmployee(head);
			}
			break;        
			case 2:{
				head = deleteEmployee(head);
			}
			break;        
			case 3:{
				display(head);
			}
			break;
			case 0:{
				flag = false;
			}
			break;
			default:
			cout << "Enter Valid Option" << endl;
			break;
		}
		cout << "Press Enter to continue..." << endl;
		getch();
		system("CLS");

	}

	return 0;
}









N3
#include<bits/stdc++.h>
using namespace std;

bool isEqual(int a,int b){
	if(a == b)
		return true;
	return false;
}

int main()
{
	int n1,n2;
	cout << "No of Terms For Equation 1 : ";
	cin >> n1;

	int arr1[n1][4];
	for (int i = 0; i < n1; i++)
	{
		cout << "Enter Coefficient : ";
		cin >> arr1[i][0];
		if (!arr1[i][0])
		{
			arr1[i][1] = 0;
			arr1[i][2] = 0;
			arr1[i][3] = 0;
			cout << "Equationzdnzs Coefficient is 0 hence the term is also 0";
			continue;
		}
		cout << "Enter Power of X : ";
		cin >> arr1[i][1];
		cout << "Enter Power of Y : ";
		cin >> arr1[i][2];
		cout << "Enter Power of Z : ";
		cin >> arr1[i][3];
	}

	cout << "No of Terms For Equation 2 : ";
	cin >> n2;

	int arr2[n2][4];
	for (int i = 0; i < n2; i++)
	{
		cout << "Enter Coefficient : ";
		cin >> arr2[i][0];
		if (!arr2[i][0])
		{
			arr2[i][1] = 0;
			arr2[i][2] = 0;
			arr2[i][3] = 0;
			// cout << "Equationzdnzs Coefficient is 0 hence the term is also 0";
			continue;
		}
		cout << "Enter Power of X : ";
		cin >> arr2[i][1];
		cout << "Enter Power of Y : ";
		cin >> arr2[i][2];
		cout << "Enter Power of Z : ";
		cin >> arr2[i][3];
	}

	//int  j = 0; 
	for (int i = 0; i < n1; i++)
	{
		for (int j = 0; j < n2; j++)
		{
			if (isEqual(arr1[i][1],arr2[j][1]) && isEqual(arr1[i][2],arr2[j][2]) && isEqual(arr1[i][3],arr2[j][3]))
			{
				arr1[i][0] += arr2[j][0];
				arr2[i][0] = 0;
			}
		}
	}

	cout << "Answer : ";
	for (int i = 0; i < n1; ++i)
	{
		if(arr1[i][0] == 0)
			continue;
		{cout << std::showpos << arr1[i][0];} 
		cout << std::noshowpos << "x^" << arr1[i][1] << "y^" << arr1[i][2] << "z^" << arr1[i][3];
	}

	for (int i = 0; i < n2; ++i)
	{
		if(arr2[i][0] == 0)
			continue;
		{cout << std::showpos << arr2[i][0];}
		cout << std::noshowpos << "x^" << arr2[i][1] << "y^" << arr2[i][2] << "z^" << arr2[i][3];
	}	
	
	return 0;
}







N4
#include<bits/stdc++.h>
#include<conio.h>
using namespace std;

class Node{
public:
	int quantity;
	string name;
	char flag;
	Node *next;
	Node *prev;

	Node(int quantity, string name,char flag){
		this->quantity = quantity;
		this->name = name;
		this->flag = flag;
		this->next = NULL;
		this->prev = NULL;
	}

};

Node* insertNode(Node* head, char flag){

	string name;
	int quantity;

	if (flag == 'v')
	{
		cout << "Enter Vegetable Name : ";
		cin >> name;
	}else{
		cout << "Enter Fruit Name : ";
		cin >> name;
	}
	cout << "Enter its quantity : ";
	cin >> quantity;

	Node* newNode = new Node(quantity,name,flag);
	
	if (head == NULL)
	{
		// If Linked List is Empty
		head = newNode;
		return head;		
	}else if(head->next == NULL){

		if (head->quantity > quantity)
		{
			head->next = newNode;
			newNode->prev = head; // Prev Info
			return head;
		}else{
			newNode->next = head;
			head->prev = newNode; // Prev Info
			head = newNode;
			return head; 
		}

	}else{

		Node* temp = head;

		if (temp->quantity < quantity)
		{
			newNode->next = temp;
			temp->prev = newNode;
			head = newNode;
			return head;
		}
		while(temp->next){
			Node* temp2 = temp->next;
			//cout << "hipHop" << endl;
			if(temp2 == NULL)
				break;
			if(temp2->quantity > quantity)
			{
				temp = temp->next;
			}
			else{
				newNode->next = temp2;
				temp->next = newNode;
				newNode->prev = temp;
				temp2->prev = newNode;
				return head;
			}

		}
		
		temp->next = newNode;
		newNode->prev = temp;
		return head;
	}
	return head;
};


char getChoice(){

	bool flag = true;
	while(flag){

		system("CLS");
		cout << "\n1.All items\n2.Vegetables\n3.Fruits\n4.Go back" <<endl;
		int ch;
		cout << "Enter Your choice : ";
		cin >> ch;
		switch(ch){
			case 1:
			{
				return 'a';
			}
			break;
			case 2:{
				return 'v';
			}
			break;
			case 3:{
				return 'f';
			}
			break;
			case 4:{
				return 'g';
			}
			break;
			default:{
				cout << "Invalid Option.." << endl;
			}
			break;
		}
	}
}

int ascDisplayNodes(char choice, Node* tail){
	
	if(choice == 'g')
		return 0;
	int ch = 0,sum = 0;
	Node* temp = tail;
	while(temp){
		//cout << choice<< temp->flag << endl;
 		if (temp->flag == choice)
		{
			if (ch == 0)
			{
				cout <<setw(5) << "|"<< setw(10)<< "Item" << " |" << setw(12) << "Quantity"  << " |" << endl;
				ch = 1;
			}
			cout <<setw(5) << "|"<< setw(10)<< temp->name << " |" << setw(12) << temp->quantity << " |"<< endl;
			sum +=temp->quantity; 
			temp = temp->prev;	
		}else if(choice == 'a'){
			if(ch == 0){
				cout <<setw(5) << "|"<< setw(10)<< "Item" << " |" << setw(12) << "Quantity"  << " |" << endl;
				ch = 1;
			}
			cout <<setw(5) << "|"<< setw(10)<< temp->name << " |" << setw(12) << temp->quantity <<" |"<< endl;
			sum +=temp->quantity;
			temp = temp->prev;
		}else{
			temp = temp->prev;
			if (temp == NULL && ch == 0)
			{
				cout << "Inventory is Empty" << endl;
			}
			continue;
		}
	}

	return sum;
}

void dscDisplayNodes(char choice,Node* head){
	if (choice == 'g')
		return;
	int ch = 0;
	Node* temp = head;
	
	while(temp){

		if (temp->flag == choice)
		{
			if (ch == 0){
				cout <<setw(5) << "|"<< setw(10)<< "Item" << " |" << setw(12) << "Quantity"  << " |" << endl;
				ch = 1;
			}
			
			cout <<setw(5) << "|"<< setw(10)<< temp->name << " |" << setw(12) << temp->quantity << " |"<< endl;
			temp = temp->next;		
		}else if(choice == 'a'){
			if(ch == 0){
				cout <<setw(5) << "|"<< setw(10)<< "Item" << " |" << setw(12) << "Quantity"  << " |" << endl;
				ch = 1;
			}
			cout <<setw(5) << "|"<< setw(10)<< temp->name << " |" << setw(12) << temp->quantity <<" |"<< endl;
			temp = temp->next;			
		}else{
			temp = temp->next;
			if (temp == NULL && ch == 0)
			{
				cout << "Inventory is Empty" << endl;
			}
			continue;
		}

	}
}


Node* getTail(Node* head){
	Node* temp = head;
	while(temp->next){
		temp = temp->next;
	}

	return temp;
}
int main()
{
	Node* head = NULL;
	Node* tail = NULL;
	while(1){
		int choice;
		cout << "[1] Insert Vegetable in Inventory" << endl;
		cout << "[2] Insert Fruit in Inventory" << endl;
		cout << "[3] Display Inventory in Ascending Order" << endl;
		cout << "[4] Display Inventory in Descending Order" << endl;
		cout << "[5] Total Display" << endl;
		cout << "[0] Exit" << endl;
		cout << "Enter Your Choice:";
		cin >> choice;

		switch(choice){
			case 1:
			head = insertNode(head,'v');
			break;
			case 2:
			head = insertNode(head,'f');
			break;
			case 3:
			if(head){
				tail = getTail(head);
				ascDisplayNodes(getChoice(),tail);
			}
			else
				cout << "Inventory is Empty" << endl;			break;
			case 4:
			if(head)
				dscDisplayNodes(getChoice(),head);
			else
				cout << "Inventory is Empty" << endl;
			break;
			case 5:
			if(head){
				tail = getTail(head);
				int sum = ascDisplayNodes(getChoice(),tail);
				if(sum)
				cout << "Total Items : "<< sum << endl;

			}
			else
				cout << "Inventory is Empty" << endl;
			break;
			case 0:
			exit(0);
			break;
			default:
				cout << "Invalid Choice..." << endl;
			break;
		}

		cout << "Press Enter to Continue.." << endl;
		getch();
		system("CLS");
	}
	
	return 0;
}
















N5
#include<bits/stdc++.h>
using namespace std;

class Stack{
char *data;
int nextIndex,capacity;
public:

	Stack(int totalSize){
		data = new char[totalSize];
		nextIndex = 0;
		capacity = totalSize;
	}

	bool isEmpty(){
		return nextIndex == 0;
	}

	void push(char element){
		if(nextIndex == capacity){
			cout << "Stack is Full" << endl;
			return;
		}

		data[nextIndex] = element;
		nextIndex++;

	}

	char pop(){
		if (isEmpty())
		{
			cout << "Stack is Empty" << endl;
			return '\0';
		}

		nextIndex--;
		return data[nextIndex];

	}

	char top(){
		return data[nextIndex-1];
	}

};

class Stack2{
int *data;
int nextIndex,capacity;
public:

	Stack2(int totalSize){
		data = new int[totalSize];
		nextIndex = 0;
		capacity = totalSize;
	}

	bool isEmpty(){
		return nextIndex == 0;
	}

	void push(int element){
		if(nextIndex == capacity){
			cout << "Stack is Full" << endl;
			return;
		}

		data[nextIndex] = element;
		nextIndex++;

	}

	int pop(){
		if (isEmpty())
		{
			cout << "Stack is Empty" << endl;
			return 0;
		}

		nextIndex--;
		return data[nextIndex];

	}

	int top(){
		if (isEmpty())
		{
			cout << "Stack is Empty" << endl;
			return 0;
		}
		return data[nextIndex-1];
	}

};

int priority(char c){
	if (c == '(')
	{
		return 0;
	}else if (c == '+' || c == '-')
	{
		return 1;
	}
	else if (c == '*' || c == '/')
	{
		return 2;
	}else if (c == '^')
	{
		return 3;
	}
}

int addition(int a,int b){
	
	return a + b;
}

int subtraction(int a,int b){
	
	return a - b;
}

int multiplication(int a,int b){
	
	return a * b;
}

int division(int a,int b){
	
	return a / b;
}

int power(int a,int b){

	return pow(a,b);
}

int main()
{
	Stack s(30);
	string str,str1 = "";
	double total;
	cout << "Enter the expression : ";
	cin >> str;

	cout << endl << "Infix Expression : " << str << endl;
	if (str[0] != '(')
	{
		str = '('+str+')'; // if input is without circular brackets
	}
	char c;
	string::iterator itr;
	cout << "Postfix Expression : ";
	for (itr = str.begin(); itr !=str.end(); itr++)
	{
		if (isalnum(*itr))
		{
			cout << *itr;
			str1 = str1 + *itr;

		}else if (*itr == '('){

			s.push(*itr);

		}else if (*itr == ')'){
			
			while((c = s.pop()) != '('){
				cout << c;
				str1 = str1 + c;
			}


		}else{
			
			while(priority(s.top()) >= priority(*itr)){
				char k = s.pop();
				cout << k;
				str1 = str1 + k;
			}
			s.push(*itr);

		}

	}

	
	while(!s.isEmpty()){
		char k = s.pop();
		cout << k;
		str1 = str1+k;

	}
	cout << endl;

	// cout << str1 << endl;

	Stack2 s1(30);
	for (int i = 0; i < str1.length(); i++)
	{
		if (isalnum(str1[i]))
		{
			s1.push((int)str1[i]-48);
		}else if (str1[i] == '*'){
			s1.push(multiplication(s1.pop(),s1.pop()));
		}else if (str1[i] == '/')
		{
			s1.push(division(s1.pop(),s1.pop()));
		}else if (str1[i] == '+')
		{
			s1.push(addition(s1.pop(),s1.pop()));
		}else if (str1[i] == '-')
		{
			s1.push(subtraction(s1.pop(),s1.pop()));
		}else if (str1[i] == '^')
		{
			s1.push(power(s1.pop(),s1.pop()));
		}
	}

	cout << "Evaluate Expression : "<< s1.pop() << endl;
	
	return 0;
}

// 2+4/5*(5-3)^5^4
// Ans 2












N6
#include<bits/stdc++.h>
using namespace std;

int main()
{
	while(true){
		int choice;
		cout << "Choose From the Following : " << endl;
		cout << "1.Queue with Priority " << endl;
		cout << "2.Queue without Priority : " << endl;
		cout << "3.Exit : " << endl;
		cin >>choice;

		switch(choice){
			case 1:{
				bool flag = true;
				while(flag){

					int btcount;
					
					cout << "How many burst time you want to Enter: ";
					cin >> btcount;
					int btwp[btcount][2];
					int wT[btcount];
					int tAT[btcount];
					int choice;
					cout << "Enter Your Choice : "<< endl;
					cout << "Enqueue"

					switch(choice)

					for (int i = 0; i < btcount; i++)
					{
						cout << "Enter the Burst time of process : ";
						cin >> btwp[i][0];

						cout << "Enter the Priority of process : ";
						cin >> btwp[i][1];
					}

					for (int i = 0; i < btcount+1; i++)
					{
						for (int j = 0; j < btcount-1; j++)
						{
							if (btwp[j][1] > btwp[j+1][1])
							{
								int temp1 = btwp[j][0]; 
								int temp2 = btwp[j][1];
								btwp[j][0] = btwp[j+1][0];
								btwp[j][1] = btwp[j+1][1];
								btwp[j+1][0] = temp1; 
								btwp[j+1][1] = temp2;

							}
						}
					}


					wT[0] = 0;
					tAT[0] = btwp[0][0];
					for (int i = 1; i < btcount; i++)
					{
						wT[i] = wT[i-1] + btwp[i-1][0];
						tAT[i] = tAT[i-1] + btwp[i][0];
					}
					cout<<"--------------------------------------------------------------------------\n";
					cout<<"\n\tSr.no.     \tBurst time \tWaiting time    Turnaround time \n";
					cout<<"--------------------------------------------------------------------------\n";
					for(int i=0;i<btcount;i++){
						cout<< setw(13)<<i+1<< setw(15) <<btwp[i][0]<<setw(19)<<wT[i]<<setw(20)<<tAT[i]<<"\n";
					}
					
					int totalWT=0 , totalTAT=0;
					for(int i=0;i<btcount;i++){
						totalWT += wT[i];
						totalTAT += tAT[i];
					}

					int avgWT = totalWT / btcount;
					int avgTAT = totalTAT / btcount;

					cout<<"--------------------------------------------------------------------------\n";
					cout<<"\t"<<"Average"<<"\t\t   "<<"\t\t     "<<avgWT<<"\t\t           "<<avgTAT<<"\n";


				}
			}
			break;
			case 2:{
				int btcount;
				cout << "How many burst count you want to enter : ";
				cin >> btcount;

				int btwp[btcount];
				int wT[btcount];
				int tAT[btcount];
				for (int i = 0; i < btcount; i++)
				{
					cout << "Enter the Burst Time of Process : ";
					cin >> btwp[i]; 
				}

				wT[0] = 0;
				tAT[0] = btwp[0];
				for (int i = 1; i < btcount; i++)
				{
					wT[i] = wT[i-1] + btwp[i-1];
					tAT[i] = tAT[i-1] + btwp[i-1];
				}

				cout<<"--------------------------------------------------------------------------\n";
				cout<<"\n\tSr.no.     \tBurst time \tWaiting time    Turnaround time \n";
				cout<<"--------------------------------------------------------------------------\n";
				for(int i=0;i<btcount;i++){
					cout<< setw(13)<<i+1<< setw(15) <<btwp[i]<<setw(19)<<wT[i]<<setw(20)<<tAT[i]<<"\n";
				}
				
				int totalWT=0 , totalTAT=0;
				for(int i=0;i<btcount;i++){
					totalWT += wT[i];
					totalTAT += tAT[i];
				}

				int avgWT = totalWT / btcount;
				int avgTAT = totalTAT / btcount;

				cout<<"--------------------------------------------------------------------------\n";
				cout<<"\t"<<"Average"<<"\t\t   "<<"\t\t     "<<avgWT<<"\t\t           "<<avgTAT<<"\n";


			}
			break;
			case 3:{
				exit(0);
			}
			break;
			default:
			break;
		}

		cout << endl;
	}

	
	return 0;
}







N7
// Redo Undo Functionality Using Doubly Linked List

#include<bits/stdc++.h>
using namespace std;

class Node{
public:
	string action;
	Node* next;
	Node* prev;

	Node(string action){
		this->action = action;
		this->next = NULL;
		this->prev = NULL;
	}
};


/* Function to insert action into UndoList */
Node* Write(string action,Node* head){

	Node* newNode = new Node(action);
	if (head == NULL)
	{
		head = newNode;
		return head;
	}else if (head->next == NULL)
	{
		head->next = newNode;
		newNode->prev = head;
		return head;
	}else{
		Node* temp = head;
		while(temp->next!=NULL){
			temp = temp->next;
		}

		temp->next = newNode;
		newNode->prev = temp;
		return head;
	}

	return head;
}


void Read(Node* head){
	Node* temp = head;
	cout << "Text Editor String : ";
	while(temp!= NULL){
		cout << temp->action[6];
		temp = temp->next;
	}
	cout << endl << endl;
}

Node* Undo(Node* Redo,Node* Undo){

	/*Check if List is empty */
	if (Undo == NULL)
	{
		cout << "Undo list is empty" << endl;
		return Redo;
	}
	/* Traversing through the Undo List */
	Node* temp = Undo;
	while(temp->next != NULL)
		temp = temp->next;
	
	/* Clear previous node next field */
	if (temp->prev != NULL)
	{
		temp->prev->next = NULL; // Important Part of Program
	}

	if (Redo == NULL)
	{
		Redo = temp;
		temp->next = NULL;
		temp->prev = NULL;
		return Redo;
	}else if (Redo->next == NULL)
	{
		Redo->next = temp;
		temp->prev = Redo;
		Redo = Redo->next;
		return Redo;
	}

	return Redo;
}

Node* Redo(Node* Redo,Node* Undo){
	
	if (Redo == NULL)
	{
		cout << "Redo List is Empty" << endl;
		return Redo;
	}

	Node* Undotemp = Undo;
	Node* Redotemp = Redo;
	if (Redo->prev !=NULL)
	{
		Redo = Redo->prev;
		Redo->next = NULL;
	}else{
		Redo = NULL;
	}

	if (Undotemp == NULL)
	{
		Undotemp = Redotemp;
	}else if (Undotemp->next == NULL)
	{
		Undotemp->next = Redotemp;
		Redotemp->prev = Undotemp;
	}else{
		while(Undotemp->next!=NULL){
			Undotemp = Undotemp->next;
		}

		Undotemp->next = Redotemp;
		Redotemp->prev = Undotemp;

	}

	return Redo;
	
}

int main()
{
	Node* UndoHead = NULL;
	Node* RedoHead = NULL;
	while(true){

	int choice;
	cout << "Choose From the following : " << endl;
	cout << "1.Write" << endl;
	cout << "2.Read" << endl;
	cout << "3.Undo" << endl;
	cout << "4.Redo" << endl;
	cout << "5.Exit" << endl;
	cout << "Enter Your choice : ";

	cin >> choice;

	switch(choice){
		case 1:{
			char c;
			cout << "Enter Your character : ";
			cin >> c;
			string b = "Write ";
			string act = b+c;
			cout << act << endl << endl;
			UndoHead = Write(act,UndoHead);
		}
		break;
		case 2:{
			Read(UndoHead);
		}
		break;
		case 3:{
			RedoHead = Undo(RedoHead,UndoHead);
		}
		break;
		case 4:{
			RedoHead = Redo(RedoHead,UndoHead);
		}
		break;
		case 5:{
			exit(0);
		}
		default:{
			cout << "Invalid Choice" << endl;
		}
	}

	}

	
	return 0;
}




N8
from drawtree import draw_bst

class Node:
	def __init__(self,data):
		self.data=data
		self.left = None
		self.right = None

def draw(l):
	draw_bst(l)

def display(root) :
	if (root != None) :
		l.append(root.data)
		display(root.left)
		display(root.right)

def postorder(root):
	if(root!=None):
		postorder(root.left)
		postorder(root.right)
		print(root.data,end=" ")

def construct(start, end):
	list = []  
	if (start > end) : 
		list.append(None)
		return list
	for i in range(start, end + 1):
		lefttree = construct(start, i - 1)
		righttree = construct(i + 1, end)
		for j in range(len(lefttree)) :
			left = lefttree[j]  
			for k in range(len(righttree)):
				right = righttree[k]
				newnode = Node(i)
				newnode.left = left
				newnode.right = right
				list.append(newnode)
	return list


l = []
print("Enter limit n1 to n2 :")
n1 = int(input())
n2 = int(input())
alltrees = construct(n1,n2)
print("all constructed BSTs are")
for i in range(len(alltrees)):
	l = []  
	display(alltrees[i])
	draw(l)
	print()
	print("--"*5)
	print() 


print("postorder of all BST's are :")
for i in range(len(alltrees)):  
	postorder(alltrees[i])
	print()
  
 
 
 N9
 
 #include <iostream>
using namespace std;

void heapify(int arr[], int n, int root)
{
   int largest = root;
   int l = 2 * root + 1;
   int r = 2 * root + 2;
   if (l < n && arr[l] > arr[largest])
      largest = l;
   if (r < n && arr[r] > arr[largest])
      largest = r;
   if (largest != root)
   {
      swap(arr[root], arr[largest]);
      heapify(arr, n, largest);
   }
}
void displayArray(int arr[], int n)
{
   for (int i = 0; i < n; ++i)
      cout << arr[i] << " ";
}
void heapSort(int arr[], int n)
{
   for (int i = n / 2 - 1; i >= 0; i--)
      heapify(arr, n, i);
   int count = 1;
   for (int i = n - 1; i > 0; i--)
   {
      displayArray(arr, n);
      cout << "    now sort " << count++ << "th element    \n\n";
      swap(arr[0], arr[i]);
      heapify(arr, i, 0);
   }
}
int main()
{
   int n;
   cout << "\nEnter the size of array : ";
   cin >> n;
   int heap_arr[n];
   cout << "\nEnter the elements of array : ";
   for (int i = 0; i < n; i++)
   {
      cin >> heap_arr[i];
   }
   cout << "Input array  :  ";
   displayArray(heap_arr, n);
   cout << "\n\n"
        << "Convert array into MAX HEAP :\n\n";
   heapSort(heap_arr, n);
   displayArray(heap_arr, n);
   cout << "    heap contains only 1 element so it is already sorted ";
   cout << "\n\n\n\nSorted array is  : ";
   displayArray(heap_arr, n);
}







N10
#include <stdio.h>
#include <conio.h>
#define INFINITY 9999
#define MAX 10

void dijkstra(int G[MAX][MAX], int n, int startnode);

int main()
{
	int G[MAX][MAX], i, j, n, u;
	printf("Enter no. of vertices:");
	scanf("%d", &n);
	printf("\nEnter the adjacency matrix:\n");

	for (i = 0; i < n; i++)
		for (j = 0; j < n; j++)
			scanf("%d", &G[i][j]);

	printf("\nEnter the starting node:");
	scanf("%d", &u);
	dijkstra(G, n, u);

	return 0;
}




void dijkstra(int G[MAX][MAX], int n, int startnode)
{

	int cost[MAX][MAX], distance[MAX], pred[MAX];
	int visited[MAX], count, mindistance, nextnode, i, j;

	// pred[] stores the predecessor of each node
	// count gives the number of nodes seen so far
	// create the cost matrix
	for (i = 0; i < n; i++)
		for (j = 0; j < n; j++)
			if (G[i][j] == 0)
				cost[i][j] = INFINITY;
			else
				cost[i][j] = G[i][j];

	// initialize pred[],distance[] and visited[]
	for (i = 0; i < n; i++)
	{
		distance[i] = cost[startnode][i];
		pred[i] = startnode;
		visited[i] = 0;
	}

	distance[startnode] = 0;
	visited[startnode] = 1;
	count = 1;

	while (count < n - 1)
	{

		mindistance = INFINITY;

		// nextnode gives the node at minimum distance
		for (i = 0; i < n; i++)
			if (distance[i] < mindistance && !visited[i])
			{
				mindistance = distance[i];
				nextnode = i;
			}

		// check if a better path exists through nextnode
		visited[nextnode] = 1;
		for (i = 0; i < n; i++)
			if (!visited[i])
				if (mindistance + cost[nextnode][i] < distance[i])
				{
					distance[i] = mindistance + cost[nextnode][i];
					pred[i] = nextnode;
				}
		count++;
	}

	// print the path and distance of each node
	for (i = 0; i < n; i++)
		if (i != startnode)
		{
			printf("\nDistance of node%d=%d", i, distance[i]);
			printf("\nPath=%d", i);

			j = i;
			do
			{
				j = pred[j];
				printf("<-%d", j);

			} while (j != startnode);
		}
}







